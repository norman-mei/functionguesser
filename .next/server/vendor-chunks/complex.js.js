"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/complex.js";
exports.ids = ["vendor-chunks/complex.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/complex.js/dist/complex.mjs":
/*!**************************************************!*\
  !*** ./node_modules/complex.js/dist/complex.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Complex: () => (/* binding */ Complex),\n/* harmony export */   \"default\": () => (/* binding */ Complex)\n/* harmony export */ });\n\n\n/**\n *\n * This class allows the manipulation of complex numbers.\n * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.\n *\n * Object form\n * { re: <real>, im: <imaginary> }\n * { arg: <angle>, abs: <radius> }\n * { phi: <angle>, r: <radius> }\n *\n * Array / Vector form\n * [ real, imaginary ]\n *\n * Double form\n * 99.3 - Single double value\n *\n * String form\n * '23.1337' - Simple real number\n * '15+3i' - a simple complex number\n * '3-i' - a simple complex number\n *\n * Example:\n *\n * const c = new Complex('99.3+8i');\n * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);\n *\n */\n\n\nconst cosh = Math.cosh || function (x) {\n  return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;\n};\n\nconst sinh = Math.sinh || function (x) {\n  return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;\n};\n\n/**\n * Calculates cos(x) - 1 using Taylor series if x is small (-¼π ≤ x ≤ ¼π).\n *\n * @param {number} x\n * @returns {number} cos(x) - 1\n */\nconst cosm1 = x => {\n  // cos(x) - 1 = − 2sin^2(x / 2)\n  const s = Math.sin(0.5 * x);\n  return -2 * s * s;\n};\n\nconst hypot = function (x, y) {\n\n  x = Math.abs(x);\n  y = Math.abs(y);\n\n  // Ensure `x` is the larger value\n  if (x < y) [x, y] = [y, x];\n\n  // If both are below the threshold, use straightforward Pythagoras\n  if (x < 1e8) return Math.sqrt(x * x + y * y);\n\n  // For larger values, scale to avoid overflow\n  y /= x;\n  return x * Math.sqrt(1 + y * y);\n};\n\nconst parser_exit = function () {\n  throw SyntaxError('Invalid Param');\n};\n\n/**\n * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows\n *\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction logHypot(a, b) {\n\n  const _a = Math.abs(a);\n  const _b = Math.abs(b);\n\n  if (a === 0) {\n    return Math.log(_b);\n  }\n\n  if (b === 0) {\n    return Math.log(_a);\n  }\n\n  if (_a < 3000 && _b < 3000) {\n    return Math.log(a * a + b * b) * 0.5;\n  }\n\n  /* I got 4 ideas to compute this property without overflow:\n   *\n   * Testing 1000000 times with random samples for a,b ∈ [1, 1000000000] against a big decimal library to get an error estimate\n   *\n   * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)\n\n   Math.log(a * a + b * b) / 2\n\n   *\n   *\n   * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)\n\n   const fn = function(a, b) {\n   a = Math.abs(a);\n   b = Math.abs(b);\n   let t = Math.min(a, b);\n   a = Math.max(a, b);\n   t = t / a;\n\n   return Math.log(a) + Math.log(1 + t * t) / 2;\n   };\n\n   * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)\n\n   Math.log(a / Math.cos(Math.atan2(b, a)))\n\n   * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)\n\n   Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))\n\n   */\n\n  a = a * 0.5;\n  b = b * 0.5;\n\n  return 0.5 * Math.log(a * a + b * b) + Math.LN2;\n}\n\nconst P = { 're': 0, 'im': 0 };\nconst parse = function (a, b) {\n\n  const z = P;\n\n  if (a === undefined || a === null) {\n    z['re'] =\n      z['im'] = 0;\n  } else if (b !== undefined) {\n    z['re'] = a;\n    z['im'] = b;\n  } else\n    switch (typeof a) {\n\n      case 'object':\n\n        if ('im' in a && 're' in a) {\n          z['re'] = a['re'];\n          z['im'] = a['im'];\n        } else if ('abs' in a && 'arg' in a) {\n          if (!isFinite(a['abs']) && isFinite(a['arg'])) {\n            return Complex['INFINITY'];\n          }\n          z['re'] = a['abs'] * Math.cos(a['arg']);\n          z['im'] = a['abs'] * Math.sin(a['arg']);\n        } else if ('r' in a && 'phi' in a) {\n          if (!isFinite(a['r']) && isFinite(a['phi'])) {\n            return Complex['INFINITY'];\n          }\n          z['re'] = a['r'] * Math.cos(a['phi']);\n          z['im'] = a['r'] * Math.sin(a['phi']);\n        } else if (a.length === 2) { // Quick array check\n          z['re'] = a[0];\n          z['im'] = a[1];\n        } else {\n          parser_exit();\n        }\n        break;\n\n      case 'string':\n\n        z['im'] = /* void */\n          z['re'] = 0;\n\n        const tokens = a.replace(/_/g, '')\n          .match(/\\d+\\.?\\d*e[+-]?\\d+|\\d+\\.?\\d*|\\.\\d+|./g);\n        let plus = 1;\n        let minus = 0;\n\n        if (tokens === null) {\n          parser_exit();\n        }\n\n        for (let i = 0; i < tokens.length; i++) {\n\n          const c = tokens[i];\n\n          if (c === ' ' || c === '\\t' || c === '\\n') {\n            /* void */\n          } else if (c === '+') {\n            plus++;\n          } else if (c === '-') {\n            minus++;\n          } else if (c === 'i' || c === 'I') {\n\n            if (plus + minus === 0) {\n              parser_exit();\n            }\n\n            if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {\n              z['im'] += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);\n              i++;\n            } else {\n              z['im'] += parseFloat((minus % 2 ? '-' : '') + '1');\n            }\n            plus = minus = 0;\n\n          } else {\n\n            if (plus + minus === 0 || isNaN(c)) {\n              parser_exit();\n            }\n\n            if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {\n              z['im'] += parseFloat((minus % 2 ? '-' : '') + c);\n              i++;\n            } else {\n              z['re'] += parseFloat((minus % 2 ? '-' : '') + c);\n            }\n            plus = minus = 0;\n          }\n        }\n\n        // Still something on the stack\n        if (plus + minus > 0) {\n          parser_exit();\n        }\n        break;\n\n      case 'number':\n        z['im'] = 0;\n        z['re'] = a;\n        break;\n\n      default:\n        parser_exit();\n    }\n\n  if (isNaN(z['re']) || isNaN(z['im'])) {\n    // If a calculation is NaN, we treat it as NaN and don't throw\n    //parser_exit();\n  }\n\n  return z;\n};\n\n/**\n * @constructor\n * @returns {Complex}\n */\nfunction Complex(a, b) {\n\n  if (!(this instanceof Complex)) {\n    return new Complex(a, b);\n  }\n\n  const z = parse(a, b);\n\n  this['re'] = z['re'];\n  this['im'] = z['im'];\n}\n\nComplex.prototype = {\n\n  're': 0,\n  'im': 0,\n\n  /**\n   * Calculates the sign of a complex number, which is a normalized complex\n   *\n   * @returns {Complex}\n   */\n  'sign': function () {\n\n    const abs = hypot(this['re'], this['im']);\n\n    return new Complex(\n      this['re'] / abs,\n      this['im'] / abs);\n  },\n\n  /**\n   * Adds two complex numbers\n   *\n   * @returns {Complex}\n   */\n  'add': function (a, b) {\n\n    const z = parse(a, b);\n\n    const tInfin = this['isInfinite']();\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\n\n    if (tInfin || zInfin) {\n\n      if (tInfin && zInfin) {\n        // Infinity + Infinity = NaN\n        return Complex['NAN'];\n      }\n      // Infinity + z = Infinity { where z != Infinity }\n      return Complex['INFINITY'];\n    }\n\n    return new Complex(\n      this['re'] + z['re'],\n      this['im'] + z['im']);\n  },\n\n  /**\n   * Subtracts two complex numbers\n   *\n   * @returns {Complex}\n   */\n  'sub': function (a, b) {\n\n    const z = parse(a, b);\n\n    const tInfin = this['isInfinite']();\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\n\n    if (tInfin || zInfin) {\n\n      if (tInfin && zInfin) {\n        // Infinity - Infinity = NaN\n        return Complex['NAN'];\n      }\n      // Infinity - z = Infinity { where z != Infinity }\n      return Complex['INFINITY'];\n    }\n\n    return new Complex(\n      this['re'] - z['re'],\n      this['im'] - z['im']);\n  },\n\n  /**\n   * Multiplies two complex numbers\n   *\n   * @returns {Complex}\n   */\n  'mul': function (a, b) {\n\n    const z = parse(a, b);\n\n    const tInfin = this['isInfinite']();\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\n    const tIsZero = this['re'] === 0 && this['im'] === 0;\n    const zIsZero = z['re'] === 0 && z['im'] === 0;\n\n    // Infinity * 0 = NaN\n    if (tInfin && zIsZero || zInfin && tIsZero) {\n      return Complex['NAN'];\n    }\n\n    // Infinity * z = Infinity { where z != 0 }\n    if (tInfin || zInfin) {\n      return Complex['INFINITY'];\n    }\n\n    // Shortcut for real values\n    if (z['im'] === 0 && this['im'] === 0) {\n      return new Complex(this['re'] * z['re'], 0);\n    }\n\n    return new Complex(\n      this['re'] * z['re'] - this['im'] * z['im'],\n      this['re'] * z['im'] + this['im'] * z['re']);\n  },\n\n  /**\n   * Divides two complex numbers\n   *\n   * @returns {Complex}\n   */\n  'div': function (a, b) {\n\n    const z = parse(a, b);\n\n    const tInfin = this['isInfinite']();\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\n    const tIsZero = this['re'] === 0 && this['im'] === 0;\n    const zIsZero = z['re'] === 0 && z['im'] === 0;\n\n    // 0 / 0 = NaN and Infinity / Infinity = NaN\n    if (tIsZero && zIsZero || tInfin && zInfin) {\n      return Complex['NAN'];\n    }\n\n    // Infinity / 0 = Infinity\n    if (zIsZero || tInfin) {\n      return Complex['INFINITY'];\n    }\n\n    // 0 / Infinity = 0\n    if (tIsZero || zInfin) {\n      return Complex['ZERO'];\n    }\n\n    if (0 === z['im']) {\n      // Divisor is real\n      return new Complex(this['re'] / z['re'], this['im'] / z['re']);\n    }\n\n    if (Math.abs(z['re']) < Math.abs(z['im'])) {\n\n      const x = z['re'] / z['im'];\n      const t = z['re'] * x + z['im'];\n\n      return new Complex(\n        (this['re'] * x + this['im']) / t,\n        (this['im'] * x - this['re']) / t);\n\n    } else {\n\n      const x = z['im'] / z['re'];\n      const t = z['im'] * x + z['re'];\n\n      return new Complex(\n        (this['re'] + this['im'] * x) / t,\n        (this['im'] - this['re'] * x) / t);\n    }\n  },\n\n  /**\n   * Calculate the power of two complex numbers\n   *\n   * @returns {Complex}\n   */\n  'pow': function (a, b) {\n\n    const z = parse(a, b);\n\n    const tIsZero = this['re'] === 0 && this['im'] === 0;\n    const zIsZero = z['re'] === 0 && z['im'] === 0;\n\n    if (zIsZero) {\n      return Complex['ONE'];\n    }\n\n    // If the exponent is real\n    if (z['im'] === 0) {\n\n      if (this['im'] === 0 && this['re'] > 0) {\n\n        return new Complex(Math.pow(this['re'], z['re']), 0);\n\n      } else if (this['re'] === 0) { // If base is fully imaginary\n\n        switch ((z['re'] % 4 + 4) % 4) {\n          case 0:\n            return new Complex(Math.pow(this['im'], z['re']), 0);\n          case 1:\n            return new Complex(0, Math.pow(this['im'], z['re']));\n          case 2:\n            return new Complex(-Math.pow(this['im'], z['re']), 0);\n          case 3:\n            return new Complex(0, -Math.pow(this['im'], z['re']));\n        }\n      }\n    }\n\n    /* I couldn't find a good formula, so here is a derivation and optimization\n     *\n     * z_1^z_2 = (a + bi)^(c + di)\n     *         = exp((c + di) * log(a + bi)\n     *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))\n     * =>...\n     * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))\n     * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))\n     *\n     * =>...\n     * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))\n     * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))\n     *\n     * =>\n     * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))\n     * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))\n     *\n     */\n\n    if (tIsZero && z['re'] > 0) { // Same behavior as Wolframalpha, Zero if real part is zero\n      return Complex['ZERO'];\n    }\n\n    const arg = Math.atan2(this['im'], this['re']);\n    const loh = logHypot(this['re'], this['im']);\n\n    let re = Math.exp(z['re'] * loh - z['im'] * arg);\n    let im = z['im'] * loh + z['re'] * arg;\n    return new Complex(\n      re * Math.cos(im),\n      re * Math.sin(im));\n  },\n\n  /**\n   * Calculate the complex square root\n   *\n   * @returns {Complex}\n   */\n  'sqrt': function () {\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (b === 0) {\n      // Real number case\n      if (a >= 0) {\n        return new Complex(Math.sqrt(a), 0);\n      } else {\n        return new Complex(0, Math.sqrt(-a));\n      }\n    }\n\n    const r = hypot(a, b);\n\n    let re = Math.sqrt(0.5 * (r + Math.abs(a))); // sqrt(2x) / 2 = sqrt(x / 2)\n    let im = Math.abs(b) / (2 * re);\n\n    if (a >= 0) {\n      return new Complex(re, b < 0 ? -im : im);\n    } else {\n      return new Complex(im, b < 0 ? -re : re);\n    }\n  },\n\n  /**\n   * Calculate the complex exponent\n   *\n   * @returns {Complex}\n   */\n  'exp': function () {\n\n    const er = Math.exp(this['re']);\n\n    if (this['im'] === 0) {\n      return new Complex(er, 0);\n    }\n    return new Complex(\n      er * Math.cos(this['im']),\n      er * Math.sin(this['im']));\n  },\n\n  /**\n   * Calculate the complex exponent and subtracts one.\n   *\n   * This may be more accurate than `Complex(x).exp().sub(1)` if\n   * `x` is small.\n   *\n   * @returns {Complex}\n   */\n  'expm1': function () {\n\n    /**\n     * exp(a + i*b) - 1\n     = exp(a) * (cos(b) + j*sin(b)) - 1\n     = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)\n     */\n\n    const a = this['re'];\n    const b = this['im'];\n\n    return new Complex(\n      Math.expm1(a) * Math.cos(b) + cosm1(b),\n      Math.exp(a) * Math.sin(b));\n  },\n\n  /**\n   * Calculate the natural log\n   *\n   * @returns {Complex}\n   */\n  'log': function () {\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (b === 0 && a > 0) {\n      return new Complex(Math.log(a), 0);\n    }\n\n    return new Complex(\n      logHypot(a, b),\n      Math.atan2(b, a));\n  },\n\n  /**\n   * Calculate the magnitude of the complex number\n   *\n   * @returns {number}\n   */\n  'abs': function () {\n\n    return hypot(this['re'], this['im']);\n  },\n\n  /**\n   * Calculate the angle of the complex number\n   *\n   * @returns {number}\n   */\n  'arg': function () {\n\n    return Math.atan2(this['im'], this['re']);\n  },\n\n  /**\n   * Calculate the sine of the complex number\n   *\n   * @returns {Complex}\n   */\n  'sin': function () {\n\n    // sin(z) = ( e^iz - e^-iz ) / 2i \n    //        = sin(a)cosh(b) + i cos(a)sinh(b)\n\n    const a = this['re'];\n    const b = this['im'];\n\n    return new Complex(\n      Math.sin(a) * cosh(b),\n      Math.cos(a) * sinh(b));\n  },\n\n  /**\n   * Calculate the cosine\n   *\n   * @returns {Complex}\n   */\n  'cos': function () {\n\n    // cos(z) = ( e^iz + e^-iz ) / 2 \n    //        = cos(a)cosh(b) - i sin(a)sinh(b)\n\n    const a = this['re'];\n    const b = this['im'];\n\n    return new Complex(\n      Math.cos(a) * cosh(b),\n      -Math.sin(a) * sinh(b));\n  },\n\n  /**\n   * Calculate the tangent\n   *\n   * @returns {Complex}\n   */\n  'tan': function () {\n\n    // tan(z) = sin(z) / cos(z) \n    //        = ( e^iz - e^-iz ) / ( i( e^iz + e^-iz ) )\n    //        = ( e^2iz - 1 ) / i( e^2iz + 1 )\n    //        = ( sin(2a) + i sinh(2b) ) / ( cos(2a) + cosh(2b) )\n\n    const a = 2 * this['re'];\n    const b = 2 * this['im'];\n    const d = Math.cos(a) + cosh(b);\n\n    return new Complex(\n      Math.sin(a) / d,\n      sinh(b) / d);\n  },\n\n  /**\n   * Calculate the cotangent\n   *\n   * @returns {Complex}\n   */\n  'cot': function () {\n\n    // cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))\n\n    const a = 2 * this['re'];\n    const b = 2 * this['im'];\n    const d = Math.cos(a) - cosh(b);\n\n    return new Complex(\n      -Math.sin(a) / d,\n      sinh(b) / d);\n  },\n\n  /**\n   * Calculate the secant\n   *\n   * @returns {Complex}\n   */\n  'sec': function () {\n\n    // sec(c) = 2 / (e^(ci) + e^(-ci))\n\n    const a = this['re'];\n    const b = this['im'];\n    const d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);\n\n    return new Complex(\n      Math.cos(a) * cosh(b) / d,\n      Math.sin(a) * sinh(b) / d);\n  },\n\n  /**\n   * Calculate the cosecans\n   *\n   * @returns {Complex}\n   */\n  'csc': function () {\n\n    // csc(c) = 2i / (e^(ci) - e^(-ci))\n\n    const a = this['re'];\n    const b = this['im'];\n    const d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);\n\n    return new Complex(\n      Math.sin(a) * cosh(b) / d,\n      -Math.cos(a) * sinh(b) / d);\n  },\n\n  /**\n   * Calculate the complex arcus sinus\n   *\n   * @returns {Complex}\n   */\n  'asin': function () {\n\n    // asin(c) = -i * log(ci + sqrt(1 - c^2))\n\n    const a = this['re'];\n    const b = this['im'];\n\n    const t1 = new Complex(\n      b * b - a * a + 1,\n      -2 * a * b)['sqrt']();\n\n    const t2 = new Complex(\n      t1['re'] - b,\n      t1['im'] + a)['log']();\n\n    return new Complex(t2['im'], -t2['re']);\n  },\n\n  /**\n   * Calculate the complex arcus cosinus\n   *\n   * @returns {Complex}\n   */\n  'acos': function () {\n\n    // acos(c) = i * log(c - i * sqrt(1 - c^2))\n\n    const a = this['re'];\n    const b = this['im'];\n\n    const t1 = new Complex(\n      b * b - a * a + 1,\n      -2 * a * b)['sqrt']();\n\n    const t2 = new Complex(\n      t1['re'] - b,\n      t1['im'] + a)['log']();\n\n    return new Complex(Math.PI / 2 - t2['im'], t2['re']);\n  },\n\n  /**\n   * Calculate the complex arcus tangent\n   *\n   * @returns {Complex}\n   */\n  'atan': function () {\n\n    // atan(c) = i / 2 log((i + x) / (i - x))\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (a === 0) {\n\n      if (b === 1) {\n        return new Complex(0, Infinity);\n      }\n\n      if (b === -1) {\n        return new Complex(0, -Infinity);\n      }\n    }\n\n    const d = a * a + (1.0 - b) * (1.0 - b);\n\n    const t1 = new Complex(\n      (1 - b * b - a * a) / d,\n      -2 * a / d).log();\n\n    return new Complex(-0.5 * t1['im'], 0.5 * t1['re']);\n  },\n\n  /**\n   * Calculate the complex arcus cotangent\n   *\n   * @returns {Complex}\n   */\n  'acot': function () {\n\n    // acot(c) = i / 2 log((c - i) / (c + i))\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (b === 0) {\n      return new Complex(Math.atan2(1, a), 0);\n    }\n\n    const d = a * a + b * b;\n    return (d !== 0)\n      ? new Complex(\n        a / d,\n        -b / d).atan()\n      : new Complex(\n        (a !== 0) ? a / 0 : 0,\n        (b !== 0) ? -b / 0 : 0).atan();\n  },\n\n  /**\n   * Calculate the complex arcus secant\n   *\n   * @returns {Complex}\n   */\n  'asec': function () {\n\n    // asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (a === 0 && b === 0) {\n      return new Complex(0, Infinity);\n    }\n\n    const d = a * a + b * b;\n    return (d !== 0)\n      ? new Complex(\n        a / d,\n        -b / d).acos()\n      : new Complex(\n        (a !== 0) ? a / 0 : 0,\n        (b !== 0) ? -b / 0 : 0).acos();\n  },\n\n  /**\n   * Calculate the complex arcus cosecans\n   *\n   * @returns {Complex}\n   */\n  'acsc': function () {\n\n    // acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (a === 0 && b === 0) {\n      return new Complex(Math.PI / 2, Infinity);\n    }\n\n    const d = a * a + b * b;\n    return (d !== 0)\n      ? new Complex(\n        a / d,\n        -b / d).asin()\n      : new Complex(\n        (a !== 0) ? a / 0 : 0,\n        (b !== 0) ? -b / 0 : 0).asin();\n  },\n\n  /**\n   * Calculate the complex sinh\n   *\n   * @returns {Complex}\n   */\n  'sinh': function () {\n\n    // sinh(c) = (e^c - e^-c) / 2\n\n    const a = this['re'];\n    const b = this['im'];\n\n    return new Complex(\n      sinh(a) * Math.cos(b),\n      cosh(a) * Math.sin(b));\n  },\n\n  /**\n   * Calculate the complex cosh\n   *\n   * @returns {Complex}\n   */\n  'cosh': function () {\n\n    // cosh(c) = (e^c + e^-c) / 2\n\n    const a = this['re'];\n    const b = this['im'];\n\n    return new Complex(\n      cosh(a) * Math.cos(b),\n      sinh(a) * Math.sin(b));\n  },\n\n  /**\n   * Calculate the complex tanh\n   *\n   * @returns {Complex}\n   */\n  'tanh': function () {\n\n    // tanh(c) = (e^c - e^-c) / (e^c + e^-c)\n\n    const a = 2 * this['re'];\n    const b = 2 * this['im'];\n    const d = cosh(a) + Math.cos(b);\n\n    return new Complex(\n      sinh(a) / d,\n      Math.sin(b) / d);\n  },\n\n  /**\n   * Calculate the complex coth\n   *\n   * @returns {Complex}\n   */\n  'coth': function () {\n\n    // coth(c) = (e^c + e^-c) / (e^c - e^-c)\n\n    const a = 2 * this['re'];\n    const b = 2 * this['im'];\n    const d = cosh(a) - Math.cos(b);\n\n    return new Complex(\n      sinh(a) / d,\n      -Math.sin(b) / d);\n  },\n\n  /**\n   * Calculate the complex csch\n   *\n   * @returns {Complex}\n   */\n  'csch': function () {\n\n    // csch(c) = 2 / (e^c - e^-c)\n\n    const a = this['re'];\n    const b = this['im'];\n    const d = Math.cos(2 * b) - cosh(2 * a);\n\n    return new Complex(\n      -2 * sinh(a) * Math.cos(b) / d,\n      2 * cosh(a) * Math.sin(b) / d);\n  },\n\n  /**\n   * Calculate the complex sech\n   *\n   * @returns {Complex}\n   */\n  'sech': function () {\n\n    // sech(c) = 2 / (e^c + e^-c)\n\n    const a = this['re'];\n    const b = this['im'];\n    const d = Math.cos(2 * b) + cosh(2 * a);\n\n    return new Complex(\n      2 * cosh(a) * Math.cos(b) / d,\n      -2 * sinh(a) * Math.sin(b) / d);\n  },\n\n  /**\n   * Calculate the complex asinh\n   *\n   * @returns {Complex}\n   */\n  'asinh': function () {\n\n    // asinh(z) = log(z + sqrt(z^2 + 1))\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (b === 0) {\n\n      if (a === 0) {\n        return new Complex(0, 0);\n      }\n\n      // Use |a| to keep asinh(-a) = -asinh(a) and avoid cancellation for large -a\n      const x = Math.abs(a);\n      const r = Math.log(x + Math.sqrt(x * x + 1));\n\n      return new Complex(a < 0 ? -r : r, 0);\n    }\n\n    // z^2 + 1 = (a^2 - b^2 + 1) + i (2ab)\n    const re2 = a * a - b * b + 1;\n    const im2 = 2 * a * b;\n\n    const t = new Complex(re2, im2)['sqrt'](); // sqrt(z^2 + 1)\n\n    return new Complex(a + t['re'], b + t['im'])['log']();\n  },\n\n  /**\n   * Calculate the complex acosh\n   *\n   * @returns {Complex}\n   */\n  'acosh': function () {\n\n    // acosh(z)= log(z + sqrt(z^2 - 1)) = log(z + sqrt(z - 1) * sqrt(z + 1))\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (b === 0) {\n\n      // z = a is real\n      if (a > 1) {\n        // acosh(a) = log(a + sqrt(a - 1) * sqrt(a + 1)),  a > 1\n        return new Complex(\n          Math.log(a + Math.sqrt(a - 1) * Math.sqrt(a + 1)), 0);\n      }\n\n      if (a < -1) {\n        // acosh(a) = log(-a + sqrt(a^2 - 1)) + i*pi,  a < -1\n        const t = Math.sqrt(a * a - 1);\n        return new Complex(Math.log(-a + t), Math.PI);\n      }\n\n      // -1 <= a <= 1 : purely imaginary\n      // acosh(a) = i * acos(a)\n      return new Complex(0, Math.acos(a));\n    }\n\n    const t1 = new Complex(a - 1, b)['sqrt'](); // sqrt(z - 1)\n    const t2 = new Complex(a + 1, b)['sqrt'](); // sqrt(z + 1)\n\n    return new Complex(\n      a + t1['re'] * t2['re'] - t1['im'] * t2['im'],\n      b + t1['re'] * t2['im'] + t1['im'] * t2['re']\n    )['log']();\n  },\n\n  /**\n   * Calculate the complex atanh\n   *\n   * @returns {Complex}\n   */\n  'atanh': function () {\n\n    // atanh(z) = log((1 + z) / (1 - z)) / 2\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (b === 0) {\n\n      if (a === 0) {\n        return new Complex(0, 0);\n      }\n\n      if (a === 1) {\n        // limit x -> 1^- atanh(x) = +Infinity\n        return new Complex(Infinity, 0);\n      }\n\n      if (a === -1) {\n        // limit x -> -1^+ atanh(x) = -Infinity\n        return new Complex(-Infinity, 0);\n      }\n\n      if (-1 < a && a < 1) {\n        // Purely real\n        return new Complex(\n          0.5 * Math.log((1 + a) / (1 - a)),\n          0\n        );\n      }\n\n      if (a > 1) {\n        // Our branch: Im(atanh(a)) = -π/2 for a > 1\n        const t = (a + 1) / (a - 1); // > 0\n        return new Complex(\n          0.5 * Math.log(t),\n          -Math.PI / 2\n        );\n      }\n\n      // a < -1: Im(atanh(a)) = +π/2\n      const t = (1 + a) / (1 - a); // < 0\n      return new Complex(\n        0.5 * Math.log(-t), // log((1 - a)/(1 + a))\n        Math.PI / 2\n      );\n    }\n\n    // Use atanh(z) = 0.5 * Log((1+z)/(1-z)) with principal Log.\n    const oneMinus = 1 - a;\n    const onePlus = 1 + a;\n    const d = oneMinus * oneMinus + b * b; // |1 - z|^2\n\n    if (d === 0) {\n      // (1 - z) == 0 for finite z only at z = 1+0i, already handled above.\n      // If we ever get here, just propagate infinities consistently:\n      return new Complex(\n        (a !== -1) ? (a / 0) : 0,\n        (b !== 0) ? (b / 0) : 0\n      );\n    }\n\n    // (1 + z) / (1 - z) with a single complex division\n    const xr = (onePlus * oneMinus - b * b) / d;\n    const xi = (b * oneMinus + onePlus * b) / d;\n\n    // 0.5 * log(xr + i xi)\n    return new Complex(\n      logHypot(xr, xi) / 2,\n      Math.atan2(xi, xr) / 2\n    );\n  },\n\n  /**\n   * Calculate the complex acoth\n   *\n   * @returns {Complex}\n   */\n  'acoth': function () {\n\n    // acoth(z) = log((z + 1) / (z - 1)) / 2 = atanh(1 / z)\n\n    const a = this['re'];\n    const b = this['im'];\n\n    // z = 0 -> acoth(0) = i * π / 2  (log((1+0)/(1-0))/2 = log(-1)/2)\n    if (a === 0 && b === 0) {\n      return new Complex(0, Math.PI / 2);\n    }\n\n    const d = a * a + b * b;\n\n    if (d !== 0) {\n      // 1 / z = (a - i b) / (a^2 + b^2)\n      return new Complex(a / d, -b / d)['atanh']();\n    }\n\n    // Fallback for weird infinities/NaNs: mirror other functions' style\n    return new Complex(\n      (a !== 0) ? a / 0 : 0,\n      (b !== 0) ? -b / 0 : 0\n    )['atanh']();\n  },\n\n  /**\n   * Calculate the complex acsch\n   *\n   * @returns {Complex}\n   */\n  'acsch': function () {\n\n    // acsch(c) = log((1+sqrt(1+c^2))/c) = = asinh(1 / z)\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (b === 0) {\n\n      // z = a real\n      if (a === 0) {\n        // acsch(0) -> +/- Infinity, we keep your previous behavior\n        return new Complex(Infinity, 0);\n      }\n\n      // acsch(a) = asinh(1/a) = log(1/a + sqrt(1/a^2 + 1))\n      const inv = 1 / a;\n      return new Complex(\n        Math.log(inv + Math.sqrt(inv * inv + 1)),\n        0\n      );\n    }\n\n    const d = a * a + b * b;\n\n    if (d !== 0) {\n      // 1/z = (a - i b) / (a^2 + b^2)\n      return new Complex(a / d, -b / d)['asinh']();\n    }\n\n    // Handle 0 + 0i or infinities in the same spirit as your existing code\n    return new Complex(\n      (a !== 0) ? a / 0 : 0,\n      (b !== 0) ? -b / 0 : 0)['asinh']();\n  },\n\n  /**\n   * Calculate the complex asech\n   *\n   * @returns {Complex}\n   */\n  'asech': function () {\n\n    // asech(z) = acosh(1 / z)\n\n    const a = this['re'];\n    const b = this['im'];\n\n    if (this['isZero']()) {\n      // asech(0) = acosh(∞) -> ∞\n      return Complex['INFINITY'];\n    }\n\n    const d = a * a + b * b;\n\n    if (d !== 0) {\n      // 1 / z = (a - i b) / (a^2 + b^2)\n      return new Complex(a / d, -b / d)['acosh']();\n    }\n\n    // Fallback for weird infinities/NaNs\n    return new Complex(\n      (a !== 0) ? a / 0 : 0,\n      (b !== 0) ? -b / 0 : 0)['acosh']();\n  },\n\n  /**\n   * Calculate the complex inverse 1/z\n   *\n   * @returns {Complex}\n   */\n  'inverse': function () {\n\n    // 1 / 0 = Infinity and 1 / Infinity = 0\n    if (this['isZero']()) {\n      return Complex['INFINITY'];\n    }\n\n    if (this['isInfinite']()) {\n      return Complex['ZERO'];\n    }\n\n    const a = this['re'];\n    const b = this['im'];\n\n    const d = a * a + b * b;\n\n    return new Complex(a / d, -b / d);\n  },\n\n  /**\n   * Returns the complex conjugate\n   *\n   * @returns {Complex}\n   */\n  'conjugate': function () {\n\n    return new Complex(this['re'], -this['im']);\n  },\n\n  /**\n   * Gets the negated complex number\n   *\n   * @returns {Complex}\n   */\n  'neg': function () {\n\n    return new Complex(-this['re'], -this['im']);\n  },\n\n  /**\n   * Ceils the actual complex number\n   *\n   * @returns {Complex}\n   */\n  'ceil': function (places) {\n\n    places = Math.pow(10, places || 0);\n\n    return new Complex(\n      Math.ceil(this['re'] * places) / places,\n      Math.ceil(this['im'] * places) / places);\n  },\n\n  /**\n   * Floors the actual complex number\n   *\n   * @returns {Complex}\n   */\n  'floor': function (places) {\n\n    places = Math.pow(10, places || 0);\n\n    return new Complex(\n      Math.floor(this['re'] * places) / places,\n      Math.floor(this['im'] * places) / places);\n  },\n\n  /**\n   * Ceils the actual complex number\n   *\n   * @returns {Complex}\n   */\n  'round': function (places) {\n\n    places = Math.pow(10, places || 0);\n\n    return new Complex(\n      Math.round(this['re'] * places) / places,\n      Math.round(this['im'] * places) / places);\n  },\n\n  /**\n   * Compares two complex numbers\n   *\n   * **Note:** new Complex(Infinity).equals(Infinity) === false\n   *\n   * @returns {boolean}\n   */\n  'equals': function (a, b) {\n\n    const z = parse(a, b);\n\n    return Math.abs(z['re'] - this['re']) <= Complex['EPSILON'] &&\n      Math.abs(z['im'] - this['im']) <= Complex['EPSILON'];\n  },\n\n  /**\n   * Clones the actual object\n   *\n   * @returns {Complex}\n   */\n  'clone': function () {\n\n    return new Complex(this['re'], this['im']);\n  },\n\n  /**\n   * Gets a string of the actual complex number\n   *\n   * @returns {string}\n   */\n  'toString': function () {\n\n    let a = this['re'];\n    let b = this['im'];\n    let ret = \"\";\n\n    if (this['isNaN']()) {\n      return 'NaN';\n    }\n\n    if (this['isInfinite']()) {\n      return 'Infinity';\n    }\n\n    if (Math.abs(a) < Complex['EPSILON']) {\n      a = 0;\n    }\n\n    if (Math.abs(b) < Complex['EPSILON']) {\n      b = 0;\n    }\n\n    // If is real number\n    if (b === 0) {\n      return ret + a;\n    }\n\n    if (a !== 0) {\n      ret += a;\n      ret += \" \";\n      if (b < 0) {\n        b = -b;\n        ret += \"-\";\n      } else {\n        ret += \"+\";\n      }\n      ret += \" \";\n    } else if (b < 0) {\n      b = -b;\n      ret += \"-\";\n    }\n\n    if (1 !== b) { // b is the absolute imaginary part\n      ret += b;\n    }\n    return ret + \"i\";\n  },\n\n  /**\n   * Returns the actual number as a vector\n   *\n   * @returns {Array}\n   */\n  'toVector': function () {\n\n    return [this['re'], this['im']];\n  },\n\n  /**\n   * Returns the actual real value of the current object\n   *\n   * @returns {number|null}\n   */\n  'valueOf': function () {\n\n    if (this['im'] === 0) {\n      return this['re'];\n    }\n    return null;\n  },\n\n  /**\n   * Determines whether a complex number is not on the Riemann sphere.\n   *\n   * @returns {boolean}\n   */\n  'isNaN': function () {\n    return isNaN(this['re']) || isNaN(this['im']);\n  },\n\n  /**\n   * Determines whether or not a complex number is at the zero pole of the\n   * Riemann sphere.\n   *\n   * @returns {boolean}\n   */\n  'isZero': function () {\n    return this['im'] === 0 && this['re'] === 0;\n  },\n\n  /**\n   * Determines whether a complex number is not at the infinity pole of the\n   * Riemann sphere.\n   *\n   * @returns {boolean}\n   */\n  'isFinite': function () {\n    return isFinite(this['re']) && isFinite(this['im']);\n  },\n\n  /**\n   * Determines whether or not a complex number is at the infinity pole of the\n   * Riemann sphere.\n   *\n   * @returns {boolean}\n   */\n  'isInfinite': function () {\n    return !this['isFinite']();\n  }\n};\n\nComplex['ZERO'] = new Complex(0, 0);\nComplex['ONE'] = new Complex(1, 0);\nComplex['I'] = new Complex(0, 1);\nComplex['PI'] = new Complex(Math.PI, 0);\nComplex['E'] = new Complex(Math.E, 0);\nComplex['INFINITY'] = new Complex(Infinity, Infinity);\nComplex['NAN'] = new Complex(NaN, NaN);\nComplex['EPSILON'] = 1e-15;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29tcGxleC5qcy9kaXN0L2NvbXBsZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQW1COztBQUUzQzs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVEsNkJBQTZCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaURBQWlEO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDOztBQUUvQztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7QUFDaEQsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnVuY3Rpb24tZ3Vlc3Nlci8uL25vZGVfbW9kdWxlcy9jb21wbGV4LmpzL2Rpc3QvY29tcGxleC5tanM/MDg2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICpcbiAqIFRoaXMgY2xhc3MgYWxsb3dzIHRoZSBtYW5pcHVsYXRpb24gb2YgY29tcGxleCBudW1iZXJzLlxuICogWW91IGNhbiBwYXNzIGEgY29tcGxleCBudW1iZXIgaW4gZGlmZmVyZW50IGZvcm1hdHMuIEVpdGhlciBhcyBvYmplY3QsIGRvdWJsZSwgc3RyaW5nIG9yIHR3byBpbnRlZ2VyIHBhcmFtZXRlcnMuXG4gKlxuICogT2JqZWN0IGZvcm1cbiAqIHsgcmU6IDxyZWFsPiwgaW06IDxpbWFnaW5hcnk+IH1cbiAqIHsgYXJnOiA8YW5nbGU+LCBhYnM6IDxyYWRpdXM+IH1cbiAqIHsgcGhpOiA8YW5nbGU+LCByOiA8cmFkaXVzPiB9XG4gKlxuICogQXJyYXkgLyBWZWN0b3IgZm9ybVxuICogWyByZWFsLCBpbWFnaW5hcnkgXVxuICpcbiAqIERvdWJsZSBmb3JtXG4gKiA5OS4zIC0gU2luZ2xlIGRvdWJsZSB2YWx1ZVxuICpcbiAqIFN0cmluZyBmb3JtXG4gKiAnMjMuMTMzNycgLSBTaW1wbGUgcmVhbCBudW1iZXJcbiAqICcxNSszaScgLSBhIHNpbXBsZSBjb21wbGV4IG51bWJlclxuICogJzMtaScgLSBhIHNpbXBsZSBjb21wbGV4IG51bWJlclxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogY29uc3QgYyA9IG5ldyBDb21wbGV4KCc5OS4zKzhpJyk7XG4gKiBjLm11bCh7cjogMywgaTogOX0pLmRpdig0LjkpLnN1YigzLCAyKTtcbiAqXG4gKi9cblxuXG5jb25zdCBjb3NoID0gTWF0aC5jb3NoIHx8IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBNYXRoLmFicyh4KSA8IDFlLTkgPyAxIC0geCA6IChNYXRoLmV4cCh4KSArIE1hdGguZXhwKC14KSkgKiAwLjU7XG59O1xuXG5jb25zdCBzaW5oID0gTWF0aC5zaW5oIHx8IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBNYXRoLmFicyh4KSA8IDFlLTkgPyB4IDogKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSAqIDAuNTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBjb3MoeCkgLSAxIHVzaW5nIFRheWxvciBzZXJpZXMgaWYgeCBpcyBzbWFsbCAoLcK8z4Ag4omkIHgg4omkIMK8z4ApLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjb3MoeCkgLSAxXG4gKi9cbmNvbnN0IGNvc20xID0geCA9PiB7XG4gIC8vIGNvcyh4KSAtIDEgPSDiiJIgMnNpbl4yKHggLyAyKVxuICBjb25zdCBzID0gTWF0aC5zaW4oMC41ICogeCk7XG4gIHJldHVybiAtMiAqIHMgKiBzO1xufTtcblxuY29uc3QgaHlwb3QgPSBmdW5jdGlvbiAoeCwgeSkge1xuXG4gIHggPSBNYXRoLmFicyh4KTtcbiAgeSA9IE1hdGguYWJzKHkpO1xuXG4gIC8vIEVuc3VyZSBgeGAgaXMgdGhlIGxhcmdlciB2YWx1ZVxuICBpZiAoeCA8IHkpIFt4LCB5XSA9IFt5LCB4XTtcblxuICAvLyBJZiBib3RoIGFyZSBiZWxvdyB0aGUgdGhyZXNob2xkLCB1c2Ugc3RyYWlnaHRmb3J3YXJkIFB5dGhhZ29yYXNcbiAgaWYgKHggPCAxZTgpIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cbiAgLy8gRm9yIGxhcmdlciB2YWx1ZXMsIHNjYWxlIHRvIGF2b2lkIG92ZXJmbG93XG4gIHkgLz0geDtcbiAgcmV0dXJuIHggKiBNYXRoLnNxcnQoMSArIHkgKiB5KTtcbn07XG5cbmNvbnN0IHBhcnNlcl9leGl0ID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBTeW50YXhFcnJvcignSW52YWxpZCBQYXJhbScpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIGxvZyhzcXJ0KGFeMitiXjIpKSBpbiBhIHdheSB0byBhdm9pZCBvdmVyZmxvd3NcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGxvZ0h5cG90KGEsIGIpIHtcblxuICBjb25zdCBfYSA9IE1hdGguYWJzKGEpO1xuICBjb25zdCBfYiA9IE1hdGguYWJzKGIpO1xuXG4gIGlmIChhID09PSAwKSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKF9iKTtcbiAgfVxuXG4gIGlmIChiID09PSAwKSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKF9hKTtcbiAgfVxuXG4gIGlmIChfYSA8IDMwMDAgJiYgX2IgPCAzMDAwKSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKGEgKiBhICsgYiAqIGIpICogMC41O1xuICB9XG5cbiAgLyogSSBnb3QgNCBpZGVhcyB0byBjb21wdXRlIHRoaXMgcHJvcGVydHkgd2l0aG91dCBvdmVyZmxvdzpcbiAgICpcbiAgICogVGVzdGluZyAxMDAwMDAwIHRpbWVzIHdpdGggcmFuZG9tIHNhbXBsZXMgZm9yIGEsYiDiiIggWzEsIDEwMDAwMDAwMDBdIGFnYWluc3QgYSBiaWcgZGVjaW1hbCBsaWJyYXJ5IHRvIGdldCBhbiBlcnJvciBlc3RpbWF0ZVxuICAgKlxuICAgKiAxLiBPbmx5IGVsaW1pbmF0ZSB0aGUgc3F1YXJlIHJvb3Q6IChPVkVSQUxMIEVSUk9SOiAzLjkxMjI0ODMwMzA5NTExMTZlLTExKVxuXG4gICBNYXRoLmxvZyhhICogYSArIGIgKiBiKSAvIDJcblxuICAgKlxuICAgKlxuICAgKiAyLiBUcnkgdG8gdXNlIHRoZSBub24tb3ZlcmZsb3dpbmcgcHl0aGFnb3JhczogKE9WRVJBTEwgRVJST1I6IDguODg5NzYwMDM5MjEwMTU5ZS0xMClcblxuICAgY29uc3QgZm4gPSBmdW5jdGlvbihhLCBiKSB7XG4gICBhID0gTWF0aC5hYnMoYSk7XG4gICBiID0gTWF0aC5hYnMoYik7XG4gICBsZXQgdCA9IE1hdGgubWluKGEsIGIpO1xuICAgYSA9IE1hdGgubWF4KGEsIGIpO1xuICAgdCA9IHQgLyBhO1xuXG4gICByZXR1cm4gTWF0aC5sb2coYSkgKyBNYXRoLmxvZygxICsgdCAqIHQpIC8gMjtcbiAgIH07XG5cbiAgICogMy4gQWJ1c2UgdGhlIGlkZW50aXR5IGNvcyhhdGFuKHkveCkgPSB4IC8gc3FydCh4XjIreV4yKTogKE9WRVJBTEwgRVJST1I6IDMuNDc4MDE3ODczNzAzNzIwNGUtMTApXG5cbiAgIE1hdGgubG9nKGEgLyBNYXRoLmNvcyhNYXRoLmF0YW4yKGIsIGEpKSlcblxuICAgKiA0LiBVc2UgMy4gYW5kIGFwcGx5IGxvZyBydWxlczogKE9WRVJBTEwgRVJST1I6IDEuMjAxNDA4NzUwMjYyMDg5NmUtOSlcblxuICAgTWF0aC5sb2coYSkgLSBNYXRoLmxvZyhNYXRoLmNvcyhNYXRoLmF0YW4yKGIsIGEpKSlcblxuICAgKi9cblxuICBhID0gYSAqIDAuNTtcbiAgYiA9IGIgKiAwLjU7XG5cbiAgcmV0dXJuIDAuNSAqIE1hdGgubG9nKGEgKiBhICsgYiAqIGIpICsgTWF0aC5MTjI7XG59XG5cbmNvbnN0IFAgPSB7ICdyZSc6IDAsICdpbSc6IDAgfTtcbmNvbnN0IHBhcnNlID0gZnVuY3Rpb24gKGEsIGIpIHtcblxuICBjb25zdCB6ID0gUDtcblxuICBpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcbiAgICB6WydyZSddID1cbiAgICAgIHpbJ2ltJ10gPSAwO1xuICB9IGVsc2UgaWYgKGIgIT09IHVuZGVmaW5lZCkge1xuICAgIHpbJ3JlJ10gPSBhO1xuICAgIHpbJ2ltJ10gPSBiO1xuICB9IGVsc2VcbiAgICBzd2l0Y2ggKHR5cGVvZiBhKSB7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG5cbiAgICAgICAgaWYgKCdpbScgaW4gYSAmJiAncmUnIGluIGEpIHtcbiAgICAgICAgICB6WydyZSddID0gYVsncmUnXTtcbiAgICAgICAgICB6WydpbSddID0gYVsnaW0nXTtcbiAgICAgICAgfSBlbHNlIGlmICgnYWJzJyBpbiBhICYmICdhcmcnIGluIGEpIHtcbiAgICAgICAgICBpZiAoIWlzRmluaXRlKGFbJ2FicyddKSAmJiBpc0Zpbml0ZShhWydhcmcnXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBDb21wbGV4WydJTkZJTklUWSddO1xuICAgICAgICAgIH1cbiAgICAgICAgICB6WydyZSddID0gYVsnYWJzJ10gKiBNYXRoLmNvcyhhWydhcmcnXSk7XG4gICAgICAgICAgelsnaW0nXSA9IGFbJ2FicyddICogTWF0aC5zaW4oYVsnYXJnJ10pO1xuICAgICAgICB9IGVsc2UgaWYgKCdyJyBpbiBhICYmICdwaGknIGluIGEpIHtcbiAgICAgICAgICBpZiAoIWlzRmluaXRlKGFbJ3InXSkgJiYgaXNGaW5pdGUoYVsncGhpJ10pKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29tcGxleFsnSU5GSU5JVFknXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgelsncmUnXSA9IGFbJ3InXSAqIE1hdGguY29zKGFbJ3BoaSddKTtcbiAgICAgICAgICB6WydpbSddID0gYVsnciddICogTWF0aC5zaW4oYVsncGhpJ10pO1xuICAgICAgICB9IGVsc2UgaWYgKGEubGVuZ3RoID09PSAyKSB7IC8vIFF1aWNrIGFycmF5IGNoZWNrXG4gICAgICAgICAgelsncmUnXSA9IGFbMF07XG4gICAgICAgICAgelsnaW0nXSA9IGFbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VyX2V4aXQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcblxuICAgICAgICB6WydpbSddID0gLyogdm9pZCAqL1xuICAgICAgICAgIHpbJ3JlJ10gPSAwO1xuXG4gICAgICAgIGNvbnN0IHRva2VucyA9IGEucmVwbGFjZSgvXy9nLCAnJylcbiAgICAgICAgICAubWF0Y2goL1xcZCtcXC4/XFxkKmVbKy1dP1xcZCt8XFxkK1xcLj9cXGQqfFxcLlxcZCt8Li9nKTtcbiAgICAgICAgbGV0IHBsdXMgPSAxO1xuICAgICAgICBsZXQgbWludXMgPSAwO1xuXG4gICAgICAgIGlmICh0b2tlbnMgPT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZXJfZXhpdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgIGNvbnN0IGMgPSB0b2tlbnNbaV07XG5cbiAgICAgICAgICBpZiAoYyA9PT0gJyAnIHx8IGMgPT09ICdcXHQnIHx8IGMgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAvKiB2b2lkICovXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnKycpIHtcbiAgICAgICAgICAgIHBsdXMrKztcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICctJykge1xuICAgICAgICAgICAgbWludXMrKztcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICdpJyB8fCBjID09PSAnSScpIHtcblxuICAgICAgICAgICAgaWYgKHBsdXMgKyBtaW51cyA9PT0gMCkge1xuICAgICAgICAgICAgICBwYXJzZXJfZXhpdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9rZW5zW2kgKyAxXSAhPT0gJyAnICYmICFpc05hTih0b2tlbnNbaSArIDFdKSkge1xuICAgICAgICAgICAgICB6WydpbSddICs9IHBhcnNlRmxvYXQoKG1pbnVzICUgMiA/ICctJyA6ICcnKSArIHRva2Vuc1tpICsgMV0pO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB6WydpbSddICs9IHBhcnNlRmxvYXQoKG1pbnVzICUgMiA/ICctJyA6ICcnKSArICcxJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbHVzID0gbWludXMgPSAwO1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKHBsdXMgKyBtaW51cyA9PT0gMCB8fCBpc05hTihjKSkge1xuICAgICAgICAgICAgICBwYXJzZXJfZXhpdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9rZW5zW2kgKyAxXSA9PT0gJ2knIHx8IHRva2Vuc1tpICsgMV0gPT09ICdJJykge1xuICAgICAgICAgICAgICB6WydpbSddICs9IHBhcnNlRmxvYXQoKG1pbnVzICUgMiA/ICctJyA6ICcnKSArIGMpO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB6WydyZSddICs9IHBhcnNlRmxvYXQoKG1pbnVzICUgMiA/ICctJyA6ICcnKSArIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGx1cyA9IG1pbnVzID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGlsbCBzb21ldGhpbmcgb24gdGhlIHN0YWNrXG4gICAgICAgIGlmIChwbHVzICsgbWludXMgPiAwKSB7XG4gICAgICAgICAgcGFyc2VyX2V4aXQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgelsnaW0nXSA9IDA7XG4gICAgICAgIHpbJ3JlJ10gPSBhO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcGFyc2VyX2V4aXQoKTtcbiAgICB9XG5cbiAgaWYgKGlzTmFOKHpbJ3JlJ10pIHx8IGlzTmFOKHpbJ2ltJ10pKSB7XG4gICAgLy8gSWYgYSBjYWxjdWxhdGlvbiBpcyBOYU4sIHdlIHRyZWF0IGl0IGFzIE5hTiBhbmQgZG9uJ3QgdGhyb3dcbiAgICAvL3BhcnNlcl9leGl0KCk7XG4gIH1cblxuICByZXR1cm4gejtcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJucyB7Q29tcGxleH1cbiAqL1xuZnVuY3Rpb24gQ29tcGxleChhLCBiKSB7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KGEsIGIpO1xuICB9XG5cbiAgY29uc3QgeiA9IHBhcnNlKGEsIGIpO1xuXG4gIHRoaXNbJ3JlJ10gPSB6WydyZSddO1xuICB0aGlzWydpbSddID0gelsnaW0nXTtcbn1cblxuQ29tcGxleC5wcm90b3R5cGUgPSB7XG5cbiAgJ3JlJzogMCxcbiAgJ2ltJzogMCxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgc2lnbiBvZiBhIGNvbXBsZXggbnVtYmVyLCB3aGljaCBpcyBhIG5vcm1hbGl6ZWQgY29tcGxleFxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdzaWduJzogZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3QgYWJzID0gaHlwb3QodGhpc1sncmUnXSwgdGhpc1snaW0nXSk7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICB0aGlzWydyZSddIC8gYWJzLFxuICAgICAgdGhpc1snaW0nXSAvIGFicyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgdHdvIGNvbXBsZXggbnVtYmVyc1xuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdhZGQnOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgY29uc3QgeiA9IHBhcnNlKGEsIGIpO1xuXG4gICAgY29uc3QgdEluZmluID0gdGhpc1snaXNJbmZpbml0ZSddKCk7XG4gICAgY29uc3QgekluZmluID0gIShpc0Zpbml0ZSh6WydyZSddKSAmJiBpc0Zpbml0ZSh6WydpbSddKSk7XG5cbiAgICBpZiAodEluZmluIHx8IHpJbmZpbikge1xuXG4gICAgICBpZiAodEluZmluICYmIHpJbmZpbikge1xuICAgICAgICAvLyBJbmZpbml0eSArIEluZmluaXR5ID0gTmFOXG4gICAgICAgIHJldHVybiBDb21wbGV4WydOQU4nXTtcbiAgICAgIH1cbiAgICAgIC8vIEluZmluaXR5ICsgeiA9IEluZmluaXR5IHsgd2hlcmUgeiAhPSBJbmZpbml0eSB9XG4gICAgICByZXR1cm4gQ29tcGxleFsnSU5GSU5JVFknXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICB0aGlzWydyZSddICsgelsncmUnXSxcbiAgICAgIHRoaXNbJ2ltJ10gKyB6WydpbSddKTtcbiAgfSxcblxuICAvKipcbiAgICogU3VidHJhY3RzIHR3byBjb21wbGV4IG51bWJlcnNcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnc3ViJzogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIGNvbnN0IHogPSBwYXJzZShhLCBiKTtcblxuICAgIGNvbnN0IHRJbmZpbiA9IHRoaXNbJ2lzSW5maW5pdGUnXSgpO1xuICAgIGNvbnN0IHpJbmZpbiA9ICEoaXNGaW5pdGUoelsncmUnXSkgJiYgaXNGaW5pdGUoelsnaW0nXSkpO1xuXG4gICAgaWYgKHRJbmZpbiB8fCB6SW5maW4pIHtcblxuICAgICAgaWYgKHRJbmZpbiAmJiB6SW5maW4pIHtcbiAgICAgICAgLy8gSW5maW5pdHkgLSBJbmZpbml0eSA9IE5hTlxuICAgICAgICByZXR1cm4gQ29tcGxleFsnTkFOJ107XG4gICAgICB9XG4gICAgICAvLyBJbmZpbml0eSAtIHogPSBJbmZpbml0eSB7IHdoZXJlIHogIT0gSW5maW5pdHkgfVxuICAgICAgcmV0dXJuIENvbXBsZXhbJ0lORklOSVRZJ107XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgdGhpc1sncmUnXSAtIHpbJ3JlJ10sXG4gICAgICB0aGlzWydpbSddIC0gelsnaW0nXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdHdvIGNvbXBsZXggbnVtYmVyc1xuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdtdWwnOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgY29uc3QgeiA9IHBhcnNlKGEsIGIpO1xuXG4gICAgY29uc3QgdEluZmluID0gdGhpc1snaXNJbmZpbml0ZSddKCk7XG4gICAgY29uc3QgekluZmluID0gIShpc0Zpbml0ZSh6WydyZSddKSAmJiBpc0Zpbml0ZSh6WydpbSddKSk7XG4gICAgY29uc3QgdElzWmVybyA9IHRoaXNbJ3JlJ10gPT09IDAgJiYgdGhpc1snaW0nXSA9PT0gMDtcbiAgICBjb25zdCB6SXNaZXJvID0gelsncmUnXSA9PT0gMCAmJiB6WydpbSddID09PSAwO1xuXG4gICAgLy8gSW5maW5pdHkgKiAwID0gTmFOXG4gICAgaWYgKHRJbmZpbiAmJiB6SXNaZXJvIHx8IHpJbmZpbiAmJiB0SXNaZXJvKSB7XG4gICAgICByZXR1cm4gQ29tcGxleFsnTkFOJ107XG4gICAgfVxuXG4gICAgLy8gSW5maW5pdHkgKiB6ID0gSW5maW5pdHkgeyB3aGVyZSB6ICE9IDAgfVxuICAgIGlmICh0SW5maW4gfHwgekluZmluKSB7XG4gICAgICByZXR1cm4gQ29tcGxleFsnSU5GSU5JVFknXTtcbiAgICB9XG5cbiAgICAvLyBTaG9ydGN1dCBmb3IgcmVhbCB2YWx1ZXNcbiAgICBpZiAoelsnaW0nXSA9PT0gMCAmJiB0aGlzWydpbSddID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgodGhpc1sncmUnXSAqIHpbJ3JlJ10sIDApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgIHRoaXNbJ3JlJ10gKiB6WydyZSddIC0gdGhpc1snaW0nXSAqIHpbJ2ltJ10sXG4gICAgICB0aGlzWydyZSddICogelsnaW0nXSArIHRoaXNbJ2ltJ10gKiB6WydyZSddKTtcbiAgfSxcblxuICAvKipcbiAgICogRGl2aWRlcyB0d28gY29tcGxleCBudW1iZXJzXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2Rpdic6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBjb25zdCB6ID0gcGFyc2UoYSwgYik7XG5cbiAgICBjb25zdCB0SW5maW4gPSB0aGlzWydpc0luZmluaXRlJ10oKTtcbiAgICBjb25zdCB6SW5maW4gPSAhKGlzRmluaXRlKHpbJ3JlJ10pICYmIGlzRmluaXRlKHpbJ2ltJ10pKTtcbiAgICBjb25zdCB0SXNaZXJvID0gdGhpc1sncmUnXSA9PT0gMCAmJiB0aGlzWydpbSddID09PSAwO1xuICAgIGNvbnN0IHpJc1plcm8gPSB6WydyZSddID09PSAwICYmIHpbJ2ltJ10gPT09IDA7XG5cbiAgICAvLyAwIC8gMCA9IE5hTiBhbmQgSW5maW5pdHkgLyBJbmZpbml0eSA9IE5hTlxuICAgIGlmICh0SXNaZXJvICYmIHpJc1plcm8gfHwgdEluZmluICYmIHpJbmZpbikge1xuICAgICAgcmV0dXJuIENvbXBsZXhbJ05BTiddO1xuICAgIH1cblxuICAgIC8vIEluZmluaXR5IC8gMCA9IEluZmluaXR5XG4gICAgaWYgKHpJc1plcm8gfHwgdEluZmluKSB7XG4gICAgICByZXR1cm4gQ29tcGxleFsnSU5GSU5JVFknXTtcbiAgICB9XG5cbiAgICAvLyAwIC8gSW5maW5pdHkgPSAwXG4gICAgaWYgKHRJc1plcm8gfHwgekluZmluKSB7XG4gICAgICByZXR1cm4gQ29tcGxleFsnWkVSTyddO1xuICAgIH1cblxuICAgIGlmICgwID09PSB6WydpbSddKSB7XG4gICAgICAvLyBEaXZpc29yIGlzIHJlYWxcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleCh0aGlzWydyZSddIC8gelsncmUnXSwgdGhpc1snaW0nXSAvIHpbJ3JlJ10pO1xuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyh6WydyZSddKSA8IE1hdGguYWJzKHpbJ2ltJ10pKSB7XG5cbiAgICAgIGNvbnN0IHggPSB6WydyZSddIC8gelsnaW0nXTtcbiAgICAgIGNvbnN0IHQgPSB6WydyZSddICogeCArIHpbJ2ltJ107XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgKHRoaXNbJ3JlJ10gKiB4ICsgdGhpc1snaW0nXSkgLyB0LFxuICAgICAgICAodGhpc1snaW0nXSAqIHggLSB0aGlzWydyZSddKSAvIHQpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgY29uc3QgeCA9IHpbJ2ltJ10gLyB6WydyZSddO1xuICAgICAgY29uc3QgdCA9IHpbJ2ltJ10gKiB4ICsgelsncmUnXTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAodGhpc1sncmUnXSArIHRoaXNbJ2ltJ10gKiB4KSAvIHQsXG4gICAgICAgICh0aGlzWydpbSddIC0gdGhpc1sncmUnXSAqIHgpIC8gdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHBvd2VyIG9mIHR3byBjb21wbGV4IG51bWJlcnNcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAncG93JzogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIGNvbnN0IHogPSBwYXJzZShhLCBiKTtcblxuICAgIGNvbnN0IHRJc1plcm8gPSB0aGlzWydyZSddID09PSAwICYmIHRoaXNbJ2ltJ10gPT09IDA7XG4gICAgY29uc3QgeklzWmVybyA9IHpbJ3JlJ10gPT09IDAgJiYgelsnaW0nXSA9PT0gMDtcblxuICAgIGlmICh6SXNaZXJvKSB7XG4gICAgICByZXR1cm4gQ29tcGxleFsnT05FJ107XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGV4cG9uZW50IGlzIHJlYWxcbiAgICBpZiAoelsnaW0nXSA9PT0gMCkge1xuXG4gICAgICBpZiAodGhpc1snaW0nXSA9PT0gMCAmJiB0aGlzWydyZSddID4gMCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleChNYXRoLnBvdyh0aGlzWydyZSddLCB6WydyZSddKSwgMCk7XG5cbiAgICAgIH0gZWxzZSBpZiAodGhpc1sncmUnXSA9PT0gMCkgeyAvLyBJZiBiYXNlIGlzIGZ1bGx5IGltYWdpbmFyeVxuXG4gICAgICAgIHN3aXRjaCAoKHpbJ3JlJ10gJSA0ICsgNCkgJSA0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KE1hdGgucG93KHRoaXNbJ2ltJ10sIHpbJ3JlJ10pLCAwKTtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoMCwgTWF0aC5wb3codGhpc1snaW0nXSwgelsncmUnXSkpO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleCgtTWF0aC5wb3codGhpc1snaW0nXSwgelsncmUnXSksIDApO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleCgwLCAtTWF0aC5wb3codGhpc1snaW0nXSwgelsncmUnXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSSBjb3VsZG4ndCBmaW5kIGEgZ29vZCBmb3JtdWxhLCBzbyBoZXJlIGlzIGEgZGVyaXZhdGlvbiBhbmQgb3B0aW1pemF0aW9uXG4gICAgICpcbiAgICAgKiB6XzFeel8yID0gKGEgKyBiaSleKGMgKyBkaSlcbiAgICAgKiAgICAgICAgID0gZXhwKChjICsgZGkpICogbG9nKGEgKyBiaSlcbiAgICAgKiAgICAgICAgID0gcG93KGFeMiArIGJeMiwgKGMgKyBkaSkgLyAyKSAqIGV4cChpKGMgKyBkaSlhdGFuMihiLCBhKSlcbiAgICAgKiA9Pi4uLlxuICAgICAqIFJlID0gKHBvdyhhXjIgKyBiXjIsIGMgLyAyKSAqIGV4cCgtZCAqIGF0YW4yKGIsIGEpKSkgKiBjb3MoZCAqIGxvZyhhXjIgKyBiXjIpIC8gMiArIGMgKiBhdGFuMihiLCBhKSlcbiAgICAgKiBJbSA9IChwb3coYV4yICsgYl4yLCBjIC8gMikgKiBleHAoLWQgKiBhdGFuMihiLCBhKSkpICogc2luKGQgKiBsb2coYV4yICsgYl4yKSAvIDIgKyBjICogYXRhbjIoYiwgYSkpXG4gICAgICpcbiAgICAgKiA9Pi4uLlxuICAgICAqIFJlID0gZXhwKGMgKiBsb2coc3FydChhXjIgKyBiXjIpKSAtIGQgKiBhdGFuMihiLCBhKSkgKiBjb3MoZCAqIGxvZyhzcXJ0KGFeMiArIGJeMikpICsgYyAqIGF0YW4yKGIsIGEpKVxuICAgICAqIEltID0gZXhwKGMgKiBsb2coc3FydChhXjIgKyBiXjIpKSAtIGQgKiBhdGFuMihiLCBhKSkgKiBzaW4oZCAqIGxvZyhzcXJ0KGFeMiArIGJeMikpICsgYyAqIGF0YW4yKGIsIGEpKVxuICAgICAqXG4gICAgICogPT5cbiAgICAgKiBSZSA9IGV4cChjICogbG9nc3EyIC0gZCAqIGFyZyh6XzEpKSAqIGNvcyhkICogbG9nc3EyICsgYyAqIGFyZyh6XzEpKVxuICAgICAqIEltID0gZXhwKGMgKiBsb2dzcTIgLSBkICogYXJnKHpfMSkpICogc2luKGQgKiBsb2dzcTIgKyBjICogYXJnKHpfMSkpXG4gICAgICpcbiAgICAgKi9cblxuICAgIGlmICh0SXNaZXJvICYmIHpbJ3JlJ10gPiAwKSB7IC8vIFNhbWUgYmVoYXZpb3IgYXMgV29sZnJhbWFscGhhLCBaZXJvIGlmIHJlYWwgcGFydCBpcyB6ZXJvXG4gICAgICByZXR1cm4gQ29tcGxleFsnWkVSTyddO1xuICAgIH1cblxuICAgIGNvbnN0IGFyZyA9IE1hdGguYXRhbjIodGhpc1snaW0nXSwgdGhpc1sncmUnXSk7XG4gICAgY29uc3QgbG9oID0gbG9nSHlwb3QodGhpc1sncmUnXSwgdGhpc1snaW0nXSk7XG5cbiAgICBsZXQgcmUgPSBNYXRoLmV4cCh6WydyZSddICogbG9oIC0gelsnaW0nXSAqIGFyZyk7XG4gICAgbGV0IGltID0gelsnaW0nXSAqIGxvaCArIHpbJ3JlJ10gKiBhcmc7XG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgcmUgKiBNYXRoLmNvcyhpbSksXG4gICAgICByZSAqIE1hdGguc2luKGltKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBzcXVhcmUgcm9vdFxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdzcXJ0JzogZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3QgYSA9IHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IHRoaXNbJ2ltJ107XG5cbiAgICBpZiAoYiA9PT0gMCkge1xuICAgICAgLy8gUmVhbCBudW1iZXIgY2FzZVxuICAgICAgaWYgKGEgPj0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5zcXJ0KGEpLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleCgwLCBNYXRoLnNxcnQoLWEpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByID0gaHlwb3QoYSwgYik7XG5cbiAgICBsZXQgcmUgPSBNYXRoLnNxcnQoMC41ICogKHIgKyBNYXRoLmFicyhhKSkpOyAvLyBzcXJ0KDJ4KSAvIDIgPSBzcXJ0KHggLyAyKVxuICAgIGxldCBpbSA9IE1hdGguYWJzKGIpIC8gKDIgKiByZSk7XG5cbiAgICBpZiAoYSA+PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgocmUsIGIgPCAwID8gLWltIDogaW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoaW0sIGIgPCAwID8gLXJlIDogcmUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGV4cG9uZW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2V4cCc6IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IGVyID0gTWF0aC5leHAodGhpc1sncmUnXSk7XG5cbiAgICBpZiAodGhpc1snaW0nXSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGVyLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgZXIgKiBNYXRoLmNvcyh0aGlzWydpbSddKSxcbiAgICAgIGVyICogTWF0aC5zaW4odGhpc1snaW0nXSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggZXhwb25lbnQgYW5kIHN1YnRyYWN0cyBvbmUuXG4gICAqXG4gICAqIFRoaXMgbWF5IGJlIG1vcmUgYWNjdXJhdGUgdGhhbiBgQ29tcGxleCh4KS5leHAoKS5zdWIoMSlgIGlmXG4gICAqIGB4YCBpcyBzbWFsbC5cbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnZXhwbTEnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBleHAoYSArIGkqYikgLSAxXG4gICAgID0gZXhwKGEpICogKGNvcyhiKSArIGoqc2luKGIpKSAtIDFcbiAgICAgPSBleHBtMShhKSpjb3MoYikgKyBjb3NtMShiKSArIGoqZXhwKGEpKnNpbihiKVxuICAgICAqL1xuXG4gICAgY29uc3QgYSA9IHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IHRoaXNbJ2ltJ107XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICBNYXRoLmV4cG0xKGEpICogTWF0aC5jb3MoYikgKyBjb3NtMShiKSxcbiAgICAgIE1hdGguZXhwKGEpICogTWF0aC5zaW4oYikpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG5hdHVyYWwgbG9nXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2xvZyc6IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IGEgPSB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSB0aGlzWydpbSddO1xuXG4gICAgaWYgKGIgPT09IDAgJiYgYSA+IDApIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChNYXRoLmxvZyhhKSwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgbG9nSHlwb3QoYSwgYiksXG4gICAgICBNYXRoLmF0YW4yKGIsIGEpKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGNvbXBsZXggbnVtYmVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICAnYWJzJzogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIGh5cG90KHRoaXNbJ3JlJ10sIHRoaXNbJ2ltJ10pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGFuZ2xlIG9mIHRoZSBjb21wbGV4IG51bWJlclxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgJ2FyZyc6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXNbJ2ltJ10sIHRoaXNbJ3JlJ10pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHNpbmUgb2YgdGhlIGNvbXBsZXggbnVtYmVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ3Npbic6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIHNpbih6KSA9ICggZV5peiAtIGVeLWl6ICkgLyAyaSBcbiAgICAvLyAgICAgICAgPSBzaW4oYSljb3NoKGIpICsgaSBjb3MoYSlzaW5oKGIpXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcblxuICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgIE1hdGguc2luKGEpICogY29zaChiKSxcbiAgICAgIE1hdGguY29zKGEpICogc2luaChiKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29zaW5lXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2Nvcyc6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGNvcyh6KSA9ICggZV5peiArIGVeLWl6ICkgLyAyIFxuICAgIC8vICAgICAgICA9IGNvcyhhKWNvc2goYikgLSBpIHNpbihhKXNpbmgoYilcblxuICAgIGNvbnN0IGEgPSB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSB0aGlzWydpbSddO1xuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgTWF0aC5jb3MoYSkgKiBjb3NoKGIpLFxuICAgICAgLU1hdGguc2luKGEpICogc2luaChiKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgdGFuZ2VudFxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICd0YW4nOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyB0YW4oeikgPSBzaW4oeikgLyBjb3MoeikgXG4gICAgLy8gICAgICAgID0gKCBlXml6IC0gZV4taXogKSAvICggaSggZV5peiArIGVeLWl6ICkgKVxuICAgIC8vICAgICAgICA9ICggZV4yaXogLSAxICkgLyBpKCBlXjJpeiArIDEgKVxuICAgIC8vICAgICAgICA9ICggc2luKDJhKSArIGkgc2luaCgyYikgKSAvICggY29zKDJhKSArIGNvc2goMmIpIClcblxuICAgIGNvbnN0IGEgPSAyICogdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gMiAqIHRoaXNbJ2ltJ107XG4gICAgY29uc3QgZCA9IE1hdGguY29zKGEpICsgY29zaChiKTtcblxuICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgIE1hdGguc2luKGEpIC8gZCxcbiAgICAgIHNpbmgoYikgLyBkKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb3RhbmdlbnRcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnY290JzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gY290KGMpID0gaShlXihjaSkgKyBlXigtY2kpKSAvIChlXihjaSkgLSBlXigtY2kpKVxuXG4gICAgY29uc3QgYSA9IDIgKiB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSAyICogdGhpc1snaW0nXTtcbiAgICBjb25zdCBkID0gTWF0aC5jb3MoYSkgLSBjb3NoKGIpO1xuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgLU1hdGguc2luKGEpIC8gZCxcbiAgICAgIHNpbmgoYikgLyBkKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBzZWNhbnRcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnc2VjJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gc2VjKGMpID0gMiAvIChlXihjaSkgKyBlXigtY2kpKVxuXG4gICAgY29uc3QgYSA9IHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IHRoaXNbJ2ltJ107XG4gICAgY29uc3QgZCA9IDAuNSAqIGNvc2goMiAqIGIpICsgMC41ICogTWF0aC5jb3MoMiAqIGEpO1xuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgTWF0aC5jb3MoYSkgKiBjb3NoKGIpIC8gZCxcbiAgICAgIE1hdGguc2luKGEpICogc2luaChiKSAvIGQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvc2VjYW5zXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2NzYyc6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGNzYyhjKSA9IDJpIC8gKGVeKGNpKSAtIGVeKC1jaSkpXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcbiAgICBjb25zdCBkID0gMC41ICogY29zaCgyICogYikgLSAwLjUgKiBNYXRoLmNvcygyICogYSk7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICBNYXRoLnNpbihhKSAqIGNvc2goYikgLyBkLFxuICAgICAgLU1hdGguY29zKGEpICogc2luaChiKSAvIGQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYXJjdXMgc2ludXNcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnYXNpbic6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGFzaW4oYykgPSAtaSAqIGxvZyhjaSArIHNxcnQoMSAtIGNeMikpXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcblxuICAgIGNvbnN0IHQxID0gbmV3IENvbXBsZXgoXG4gICAgICBiICogYiAtIGEgKiBhICsgMSxcbiAgICAgIC0yICogYSAqIGIpWydzcXJ0J10oKTtcblxuICAgIGNvbnN0IHQyID0gbmV3IENvbXBsZXgoXG4gICAgICB0MVsncmUnXSAtIGIsXG4gICAgICB0MVsnaW0nXSArIGEpWydsb2cnXSgpO1xuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KHQyWydpbSddLCAtdDJbJ3JlJ10pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYXJjdXMgY29zaW51c1xuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdhY29zJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gYWNvcyhjKSA9IGkgKiBsb2coYyAtIGkgKiBzcXJ0KDEgLSBjXjIpKVxuXG4gICAgY29uc3QgYSA9IHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IHRoaXNbJ2ltJ107XG5cbiAgICBjb25zdCB0MSA9IG5ldyBDb21wbGV4KFxuICAgICAgYiAqIGIgLSBhICogYSArIDEsXG4gICAgICAtMiAqIGEgKiBiKVsnc3FydCddKCk7XG5cbiAgICBjb25zdCB0MiA9IG5ldyBDb21wbGV4KFxuICAgICAgdDFbJ3JlJ10gLSBiLFxuICAgICAgdDFbJ2ltJ10gKyBhKVsnbG9nJ10oKTtcblxuICAgIHJldHVybiBuZXcgQ29tcGxleChNYXRoLlBJIC8gMiAtIHQyWydpbSddLCB0MlsncmUnXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBhcmN1cyB0YW5nZW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2F0YW4nOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBhdGFuKGMpID0gaSAvIDIgbG9nKChpICsgeCkgLyAoaSAtIHgpKVxuXG4gICAgY29uc3QgYSA9IHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IHRoaXNbJ2ltJ107XG5cbiAgICBpZiAoYSA9PT0gMCkge1xuXG4gICAgICBpZiAoYiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoMCwgSW5maW5pdHkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYiA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KDAsIC1JbmZpbml0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZCA9IGEgKiBhICsgKDEuMCAtIGIpICogKDEuMCAtIGIpO1xuXG4gICAgY29uc3QgdDEgPSBuZXcgQ29tcGxleChcbiAgICAgICgxIC0gYiAqIGIgLSBhICogYSkgLyBkLFxuICAgICAgLTIgKiBhIC8gZCkubG9nKCk7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoLTAuNSAqIHQxWydpbSddLCAwLjUgKiB0MVsncmUnXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBhcmN1cyBjb3RhbmdlbnRcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnYWNvdCc6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGFjb3QoYykgPSBpIC8gMiBsb2coKGMgLSBpKSAvIChjICsgaSkpXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcblxuICAgIGlmIChiID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5hdGFuMigxLCBhKSwgMCk7XG4gICAgfVxuXG4gICAgY29uc3QgZCA9IGEgKiBhICsgYiAqIGI7XG4gICAgcmV0dXJuIChkICE9PSAwKVxuICAgICAgPyBuZXcgQ29tcGxleChcbiAgICAgICAgYSAvIGQsXG4gICAgICAgIC1iIC8gZCkuYXRhbigpXG4gICAgICA6IG5ldyBDb21wbGV4KFxuICAgICAgICAoYSAhPT0gMCkgPyBhIC8gMCA6IDAsXG4gICAgICAgIChiICE9PSAwKSA/IC1iIC8gMCA6IDApLmF0YW4oKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFyY3VzIHNlY2FudFxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdhc2VjJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gYXNlYyhjKSA9IC1pICogbG9nKDEgLyBjICsgc3FydCgxIC0gaSAvIGNeMikpXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcblxuICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleCgwLCBJbmZpbml0eSk7XG4gICAgfVxuXG4gICAgY29uc3QgZCA9IGEgKiBhICsgYiAqIGI7XG4gICAgcmV0dXJuIChkICE9PSAwKVxuICAgICAgPyBuZXcgQ29tcGxleChcbiAgICAgICAgYSAvIGQsXG4gICAgICAgIC1iIC8gZCkuYWNvcygpXG4gICAgICA6IG5ldyBDb21wbGV4KFxuICAgICAgICAoYSAhPT0gMCkgPyBhIC8gMCA6IDAsXG4gICAgICAgIChiICE9PSAwKSA/IC1iIC8gMCA6IDApLmFjb3MoKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFyY3VzIGNvc2VjYW5zXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2Fjc2MnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBhY3NjKGMpID0gLWkgKiBsb2coaSAvIGMgKyBzcXJ0KDEgLSAxIC8gY14yKSlcblxuICAgIGNvbnN0IGEgPSB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSB0aGlzWydpbSddO1xuXG4gICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KE1hdGguUEkgLyAyLCBJbmZpbml0eSk7XG4gICAgfVxuXG4gICAgY29uc3QgZCA9IGEgKiBhICsgYiAqIGI7XG4gICAgcmV0dXJuIChkICE9PSAwKVxuICAgICAgPyBuZXcgQ29tcGxleChcbiAgICAgICAgYSAvIGQsXG4gICAgICAgIC1iIC8gZCkuYXNpbigpXG4gICAgICA6IG5ldyBDb21wbGV4KFxuICAgICAgICAoYSAhPT0gMCkgPyBhIC8gMCA6IDAsXG4gICAgICAgIChiICE9PSAwKSA/IC1iIC8gMCA6IDApLmFzaW4oKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IHNpbmhcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnc2luaCc6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIHNpbmgoYykgPSAoZV5jIC0gZV4tYykgLyAyXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcblxuICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgIHNpbmgoYSkgKiBNYXRoLmNvcyhiKSxcbiAgICAgIGNvc2goYSkgKiBNYXRoLnNpbihiKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBjb3NoXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2Nvc2gnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBjb3NoKGMpID0gKGVeYyArIGVeLWMpIC8gMlxuXG4gICAgY29uc3QgYSA9IHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IHRoaXNbJ2ltJ107XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICBjb3NoKGEpICogTWF0aC5jb3MoYiksXG4gICAgICBzaW5oKGEpICogTWF0aC5zaW4oYikpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggdGFuaFxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICd0YW5oJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gdGFuaChjKSA9IChlXmMgLSBlXi1jKSAvIChlXmMgKyBlXi1jKVxuXG4gICAgY29uc3QgYSA9IDIgKiB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSAyICogdGhpc1snaW0nXTtcbiAgICBjb25zdCBkID0gY29zaChhKSArIE1hdGguY29zKGIpO1xuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgc2luaChhKSAvIGQsXG4gICAgICBNYXRoLnNpbihiKSAvIGQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggY290aFxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdjb3RoJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gY290aChjKSA9IChlXmMgKyBlXi1jKSAvIChlXmMgLSBlXi1jKVxuXG4gICAgY29uc3QgYSA9IDIgKiB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSAyICogdGhpc1snaW0nXTtcbiAgICBjb25zdCBkID0gY29zaChhKSAtIE1hdGguY29zKGIpO1xuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgc2luaChhKSAvIGQsXG4gICAgICAtTWF0aC5zaW4oYikgLyBkKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGNzY2hcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnY3NjaCc6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGNzY2goYykgPSAyIC8gKGVeYyAtIGVeLWMpXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcbiAgICBjb25zdCBkID0gTWF0aC5jb3MoMiAqIGIpIC0gY29zaCgyICogYSk7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAtMiAqIHNpbmgoYSkgKiBNYXRoLmNvcyhiKSAvIGQsXG4gICAgICAyICogY29zaChhKSAqIE1hdGguc2luKGIpIC8gZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBzZWNoXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ3NlY2gnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBzZWNoKGMpID0gMiAvIChlXmMgKyBlXi1jKVxuXG4gICAgY29uc3QgYSA9IHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IHRoaXNbJ2ltJ107XG4gICAgY29uc3QgZCA9IE1hdGguY29zKDIgKiBiKSArIGNvc2goMiAqIGEpO1xuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgMiAqIGNvc2goYSkgKiBNYXRoLmNvcyhiKSAvIGQsXG4gICAgICAtMiAqIHNpbmgoYSkgKiBNYXRoLnNpbihiKSAvIGQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYXNpbmhcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnYXNpbmgnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBhc2luaCh6KSA9IGxvZyh6ICsgc3FydCh6XjIgKyAxKSlcblxuICAgIGNvbnN0IGEgPSB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSB0aGlzWydpbSddO1xuXG4gICAgaWYgKGIgPT09IDApIHtcblxuICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KDAsIDApO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2UgfGF8IHRvIGtlZXAgYXNpbmgoLWEpID0gLWFzaW5oKGEpIGFuZCBhdm9pZCBjYW5jZWxsYXRpb24gZm9yIGxhcmdlIC1hXG4gICAgICBjb25zdCB4ID0gTWF0aC5hYnMoYSk7XG4gICAgICBjb25zdCByID0gTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGEgPCAwID8gLXIgOiByLCAwKTtcbiAgICB9XG5cbiAgICAvLyB6XjIgKyAxID0gKGFeMiAtIGJeMiArIDEpICsgaSAoMmFiKVxuICAgIGNvbnN0IHJlMiA9IGEgKiBhIC0gYiAqIGIgKyAxO1xuICAgIGNvbnN0IGltMiA9IDIgKiBhICogYjtcblxuICAgIGNvbnN0IHQgPSBuZXcgQ29tcGxleChyZTIsIGltMilbJ3NxcnQnXSgpOyAvLyBzcXJ0KHpeMiArIDEpXG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoYSArIHRbJ3JlJ10sIGIgKyB0WydpbSddKVsnbG9nJ10oKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFjb3NoXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2Fjb3NoJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gYWNvc2goeik9IGxvZyh6ICsgc3FydCh6XjIgLSAxKSkgPSBsb2coeiArIHNxcnQoeiAtIDEpICogc3FydCh6ICsgMSkpXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcblxuICAgIGlmIChiID09PSAwKSB7XG5cbiAgICAgIC8vIHogPSBhIGlzIHJlYWxcbiAgICAgIGlmIChhID4gMSkge1xuICAgICAgICAvLyBhY29zaChhKSA9IGxvZyhhICsgc3FydChhIC0gMSkgKiBzcXJ0KGEgKyAxKSksICBhID4gMVxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgTWF0aC5sb2coYSArIE1hdGguc3FydChhIC0gMSkgKiBNYXRoLnNxcnQoYSArIDEpKSwgMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhIDwgLTEpIHtcbiAgICAgICAgLy8gYWNvc2goYSkgPSBsb2coLWEgKyBzcXJ0KGFeMiAtIDEpKSArIGkqcGksICBhIDwgLTFcbiAgICAgICAgY29uc3QgdCA9IE1hdGguc3FydChhICogYSAtIDEpO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5sb2coLWEgKyB0KSwgTWF0aC5QSSk7XG4gICAgICB9XG5cbiAgICAgIC8vIC0xIDw9IGEgPD0gMSA6IHB1cmVseSBpbWFnaW5hcnlcbiAgICAgIC8vIGFjb3NoKGEpID0gaSAqIGFjb3MoYSlcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleCgwLCBNYXRoLmFjb3MoYSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHQxID0gbmV3IENvbXBsZXgoYSAtIDEsIGIpWydzcXJ0J10oKTsgLy8gc3FydCh6IC0gMSlcbiAgICBjb25zdCB0MiA9IG5ldyBDb21wbGV4KGEgKyAxLCBiKVsnc3FydCddKCk7IC8vIHNxcnQoeiArIDEpXG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICBhICsgdDFbJ3JlJ10gKiB0MlsncmUnXSAtIHQxWydpbSddICogdDJbJ2ltJ10sXG4gICAgICBiICsgdDFbJ3JlJ10gKiB0MlsnaW0nXSArIHQxWydpbSddICogdDJbJ3JlJ11cbiAgICApWydsb2cnXSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYXRhbmhcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnYXRhbmgnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBhdGFuaCh6KSA9IGxvZygoMSArIHopIC8gKDEgLSB6KSkgLyAyXG5cbiAgICBjb25zdCBhID0gdGhpc1sncmUnXTtcbiAgICBjb25zdCBiID0gdGhpc1snaW0nXTtcblxuICAgIGlmIChiID09PSAwKSB7XG5cbiAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleCgwLCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGEgPT09IDEpIHtcbiAgICAgICAgLy8gbGltaXQgeCAtPiAxXi0gYXRhbmgoeCkgPSArSW5maW5pdHlcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KEluZmluaXR5LCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGEgPT09IC0xKSB7XG4gICAgICAgIC8vIGxpbWl0IHggLT4gLTFeKyBhdGFuaCh4KSA9IC1JbmZpbml0eVxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoLUluZmluaXR5LCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKC0xIDwgYSAmJiBhIDwgMSkge1xuICAgICAgICAvLyBQdXJlbHkgcmVhbFxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgMC41ICogTWF0aC5sb2coKDEgKyBhKSAvICgxIC0gYSkpLFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGEgPiAxKSB7XG4gICAgICAgIC8vIE91ciBicmFuY2g6IEltKGF0YW5oKGEpKSA9IC3PgC8yIGZvciBhID4gMVxuICAgICAgICBjb25zdCB0ID0gKGEgKyAxKSAvIChhIC0gMSk7IC8vID4gMFxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgMC41ICogTWF0aC5sb2codCksXG4gICAgICAgICAgLU1hdGguUEkgLyAyXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGEgPCAtMTogSW0oYXRhbmgoYSkpID0gK8+ALzJcbiAgICAgIGNvbnN0IHQgPSAoMSArIGEpIC8gKDEgLSBhKTsgLy8gPCAwXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgIDAuNSAqIE1hdGgubG9nKC10KSwgLy8gbG9nKCgxIC0gYSkvKDEgKyBhKSlcbiAgICAgICAgTWF0aC5QSSAvIDJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVXNlIGF0YW5oKHopID0gMC41ICogTG9nKCgxK3opLygxLXopKSB3aXRoIHByaW5jaXBhbCBMb2cuXG4gICAgY29uc3Qgb25lTWludXMgPSAxIC0gYTtcbiAgICBjb25zdCBvbmVQbHVzID0gMSArIGE7XG4gICAgY29uc3QgZCA9IG9uZU1pbnVzICogb25lTWludXMgKyBiICogYjsgLy8gfDEgLSB6fF4yXG5cbiAgICBpZiAoZCA9PT0gMCkge1xuICAgICAgLy8gKDEgLSB6KSA9PSAwIGZvciBmaW5pdGUgeiBvbmx5IGF0IHogPSAxKzBpLCBhbHJlYWR5IGhhbmRsZWQgYWJvdmUuXG4gICAgICAvLyBJZiB3ZSBldmVyIGdldCBoZXJlLCBqdXN0IHByb3BhZ2F0ZSBpbmZpbml0aWVzIGNvbnNpc3RlbnRseTpcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgKGEgIT09IC0xKSA/IChhIC8gMCkgOiAwLFxuICAgICAgICAoYiAhPT0gMCkgPyAoYiAvIDApIDogMFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyAoMSArIHopIC8gKDEgLSB6KSB3aXRoIGEgc2luZ2xlIGNvbXBsZXggZGl2aXNpb25cbiAgICBjb25zdCB4ciA9IChvbmVQbHVzICogb25lTWludXMgLSBiICogYikgLyBkO1xuICAgIGNvbnN0IHhpID0gKGIgKiBvbmVNaW51cyArIG9uZVBsdXMgKiBiKSAvIGQ7XG5cbiAgICAvLyAwLjUgKiBsb2coeHIgKyBpIHhpKVxuICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgIGxvZ0h5cG90KHhyLCB4aSkgLyAyLFxuICAgICAgTWF0aC5hdGFuMih4aSwgeHIpIC8gMlxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBhY290aFxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdhY290aCc6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGFjb3RoKHopID0gbG9nKCh6ICsgMSkgLyAoeiAtIDEpKSAvIDIgPSBhdGFuaCgxIC8geilcblxuICAgIGNvbnN0IGEgPSB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSB0aGlzWydpbSddO1xuXG4gICAgLy8geiA9IDAgLT4gYWNvdGgoMCkgPSBpICogz4AgLyAyICAobG9nKCgxKzApLygxLTApKS8yID0gbG9nKC0xKS8yKVxuICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleCgwLCBNYXRoLlBJIC8gMik7XG4gICAgfVxuXG4gICAgY29uc3QgZCA9IGEgKiBhICsgYiAqIGI7XG5cbiAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgLy8gMSAvIHogPSAoYSAtIGkgYikgLyAoYV4yICsgYl4yKVxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGEgLyBkLCAtYiAvIGQpWydhdGFuaCddKCk7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIHdlaXJkIGluZmluaXRpZXMvTmFOczogbWlycm9yIG90aGVyIGZ1bmN0aW9ucycgc3R5bGVcbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAoYSAhPT0gMCkgPyBhIC8gMCA6IDAsXG4gICAgICAoYiAhPT0gMCkgPyAtYiAvIDAgOiAwXG4gICAgKVsnYXRhbmgnXSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYWNzY2hcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnYWNzY2gnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBhY3NjaChjKSA9IGxvZygoMStzcXJ0KDErY14yKSkvYykgPSA9IGFzaW5oKDEgLyB6KVxuXG4gICAgY29uc3QgYSA9IHRoaXNbJ3JlJ107XG4gICAgY29uc3QgYiA9IHRoaXNbJ2ltJ107XG5cbiAgICBpZiAoYiA9PT0gMCkge1xuXG4gICAgICAvLyB6ID0gYSByZWFsXG4gICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAvLyBhY3NjaCgwKSAtPiArLy0gSW5maW5pdHksIHdlIGtlZXAgeW91ciBwcmV2aW91cyBiZWhhdmlvclxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoSW5maW5pdHksIDApO1xuICAgICAgfVxuXG4gICAgICAvLyBhY3NjaChhKSA9IGFzaW5oKDEvYSkgPSBsb2coMS9hICsgc3FydCgxL2FeMiArIDEpKVxuICAgICAgY29uc3QgaW52ID0gMSAvIGE7XG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgIE1hdGgubG9nKGludiArIE1hdGguc3FydChpbnYgKiBpbnYgKyAxKSksXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZCA9IGEgKiBhICsgYiAqIGI7XG5cbiAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgLy8gMS96ID0gKGEgLSBpIGIpIC8gKGFeMiArIGJeMilcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChhIC8gZCwgLWIgLyBkKVsnYXNpbmgnXSgpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSAwICsgMGkgb3IgaW5maW5pdGllcyBpbiB0aGUgc2FtZSBzcGlyaXQgYXMgeW91ciBleGlzdGluZyBjb2RlXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgKGEgIT09IDApID8gYSAvIDAgOiAwLFxuICAgICAgKGIgIT09IDApID8gLWIgLyAwIDogMClbJ2FzaW5oJ10oKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFzZWNoXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2FzZWNoJzogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gYXNlY2goeikgPSBhY29zaCgxIC8geilcblxuICAgIGNvbnN0IGEgPSB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSB0aGlzWydpbSddO1xuXG4gICAgaWYgKHRoaXNbJ2lzWmVybyddKCkpIHtcbiAgICAgIC8vIGFzZWNoKDApID0gYWNvc2go4oieKSAtPiDiiJ5cbiAgICAgIHJldHVybiBDb21wbGV4WydJTkZJTklUWSddO1xuICAgIH1cblxuICAgIGNvbnN0IGQgPSBhICogYSArIGIgKiBiO1xuXG4gICAgaWYgKGQgIT09IDApIHtcbiAgICAgIC8vIDEgLyB6ID0gKGEgLSBpIGIpIC8gKGFeMiArIGJeMilcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChhIC8gZCwgLWIgLyBkKVsnYWNvc2gnXSgpO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciB3ZWlyZCBpbmZpbml0aWVzL05hTnNcbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAoYSAhPT0gMCkgPyBhIC8gMCA6IDAsXG4gICAgICAoYiAhPT0gMCkgPyAtYiAvIDAgOiAwKVsnYWNvc2gnXSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggaW52ZXJzZSAxL3pcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnaW52ZXJzZSc6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIDEgLyAwID0gSW5maW5pdHkgYW5kIDEgLyBJbmZpbml0eSA9IDBcbiAgICBpZiAodGhpc1snaXNaZXJvJ10oKSkge1xuICAgICAgcmV0dXJuIENvbXBsZXhbJ0lORklOSVRZJ107XG4gICAgfVxuXG4gICAgaWYgKHRoaXNbJ2lzSW5maW5pdGUnXSgpKSB7XG4gICAgICByZXR1cm4gQ29tcGxleFsnWkVSTyddO1xuICAgIH1cblxuICAgIGNvbnN0IGEgPSB0aGlzWydyZSddO1xuICAgIGNvbnN0IGIgPSB0aGlzWydpbSddO1xuXG4gICAgY29uc3QgZCA9IGEgKiBhICsgYiAqIGI7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoYSAvIGQsIC1iIC8gZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbXBsZXggY29uanVnYXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgJ2Nvbmp1Z2F0ZSc6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgQ29tcGxleCh0aGlzWydyZSddLCAtdGhpc1snaW0nXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5lZ2F0ZWQgY29tcGxleCBudW1iZXJcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnbmVnJzogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KC10aGlzWydyZSddLCAtdGhpc1snaW0nXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENlaWxzIHRoZSBhY3R1YWwgY29tcGxleCBudW1iZXJcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnY2VpbCc6IGZ1bmN0aW9uIChwbGFjZXMpIHtcblxuICAgIHBsYWNlcyA9IE1hdGgucG93KDEwLCBwbGFjZXMgfHwgMCk7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICBNYXRoLmNlaWwodGhpc1sncmUnXSAqIHBsYWNlcykgLyBwbGFjZXMsXG4gICAgICBNYXRoLmNlaWwodGhpc1snaW0nXSAqIHBsYWNlcykgLyBwbGFjZXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGbG9vcnMgdGhlIGFjdHVhbCBjb21wbGV4IG51bWJlclxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICovXG4gICdmbG9vcic6IGZ1bmN0aW9uIChwbGFjZXMpIHtcblxuICAgIHBsYWNlcyA9IE1hdGgucG93KDEwLCBwbGFjZXMgfHwgMCk7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICBNYXRoLmZsb29yKHRoaXNbJ3JlJ10gKiBwbGFjZXMpIC8gcGxhY2VzLFxuICAgICAgTWF0aC5mbG9vcih0aGlzWydpbSddICogcGxhY2VzKSAvIHBsYWNlcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENlaWxzIHRoZSBhY3R1YWwgY29tcGxleCBudW1iZXJcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAncm91bmQnOiBmdW5jdGlvbiAocGxhY2VzKSB7XG5cbiAgICBwbGFjZXMgPSBNYXRoLnBvdygxMCwgcGxhY2VzIHx8IDApO1xuXG4gICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgTWF0aC5yb3VuZCh0aGlzWydyZSddICogcGxhY2VzKSAvIHBsYWNlcyxcbiAgICAgIE1hdGgucm91bmQodGhpc1snaW0nXSAqIHBsYWNlcykgLyBwbGFjZXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0d28gY29tcGxleCBudW1iZXJzXG4gICAqXG4gICAqICoqTm90ZToqKiBuZXcgQ29tcGxleChJbmZpbml0eSkuZXF1YWxzKEluZmluaXR5KSA9PT0gZmFsc2VcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICAnZXF1YWxzJzogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIGNvbnN0IHogPSBwYXJzZShhLCBiKTtcblxuICAgIHJldHVybiBNYXRoLmFicyh6WydyZSddIC0gdGhpc1sncmUnXSkgPD0gQ29tcGxleFsnRVBTSUxPTiddICYmXG4gICAgICBNYXRoLmFicyh6WydpbSddIC0gdGhpc1snaW0nXSkgPD0gQ29tcGxleFsnRVBTSUxPTiddO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIGFjdHVhbCBvYmplY3RcbiAgICpcbiAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAqL1xuICAnY2xvbmUnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IENvbXBsZXgodGhpc1sncmUnXSwgdGhpc1snaW0nXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgYSBzdHJpbmcgb2YgdGhlIGFjdHVhbCBjb21wbGV4IG51bWJlclxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgJ3RvU3RyaW5nJzogZnVuY3Rpb24gKCkge1xuXG4gICAgbGV0IGEgPSB0aGlzWydyZSddO1xuICAgIGxldCBiID0gdGhpc1snaW0nXTtcbiAgICBsZXQgcmV0ID0gXCJcIjtcblxuICAgIGlmICh0aGlzWydpc05hTiddKCkpIHtcbiAgICAgIHJldHVybiAnTmFOJztcbiAgICB9XG5cbiAgICBpZiAodGhpc1snaXNJbmZpbml0ZSddKCkpIHtcbiAgICAgIHJldHVybiAnSW5maW5pdHknO1xuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyhhKSA8IENvbXBsZXhbJ0VQU0lMT04nXSkge1xuICAgICAgYSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKGIpIDwgQ29tcGxleFsnRVBTSUxPTiddKSB7XG4gICAgICBiID0gMDtcbiAgICB9XG5cbiAgICAvLyBJZiBpcyByZWFsIG51bWJlclxuICAgIGlmIChiID09PSAwKSB7XG4gICAgICByZXR1cm4gcmV0ICsgYTtcbiAgICB9XG5cbiAgICBpZiAoYSAhPT0gMCkge1xuICAgICAgcmV0ICs9IGE7XG4gICAgICByZXQgKz0gXCIgXCI7XG4gICAgICBpZiAoYiA8IDApIHtcbiAgICAgICAgYiA9IC1iO1xuICAgICAgICByZXQgKz0gXCItXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgKz0gXCIrXCI7XG4gICAgICB9XG4gICAgICByZXQgKz0gXCIgXCI7XG4gICAgfSBlbHNlIGlmIChiIDwgMCkge1xuICAgICAgYiA9IC1iO1xuICAgICAgcmV0ICs9IFwiLVwiO1xuICAgIH1cblxuICAgIGlmICgxICE9PSBiKSB7IC8vIGIgaXMgdGhlIGFic29sdXRlIGltYWdpbmFyeSBwYXJ0XG4gICAgICByZXQgKz0gYjtcbiAgICB9XG4gICAgcmV0dXJuIHJldCArIFwiaVwiO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhY3R1YWwgbnVtYmVyIGFzIGEgdmVjdG9yXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gICd0b1ZlY3Rvcic6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBbdGhpc1sncmUnXSwgdGhpc1snaW0nXV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFjdHVhbCByZWFsIHZhbHVlIG9mIHRoZSBjdXJyZW50IG9iamVjdFxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfG51bGx9XG4gICAqL1xuICAndmFsdWVPZic6IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICh0aGlzWydpbSddID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpc1sncmUnXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhIGNvbXBsZXggbnVtYmVyIGlzIG5vdCBvbiB0aGUgUmllbWFubiBzcGhlcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgJ2lzTmFOJzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc05hTih0aGlzWydyZSddKSB8fCBpc05hTih0aGlzWydpbSddKTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCBhIGNvbXBsZXggbnVtYmVyIGlzIGF0IHRoZSB6ZXJvIHBvbGUgb2YgdGhlXG4gICAqIFJpZW1hbm4gc3BoZXJlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gICdpc1plcm8nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbJ2ltJ10gPT09IDAgJiYgdGhpc1sncmUnXSA9PT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgY29tcGxleCBudW1iZXIgaXMgbm90IGF0IHRoZSBpbmZpbml0eSBwb2xlIG9mIHRoZVxuICAgKiBSaWVtYW5uIHNwaGVyZS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICAnaXNGaW5pdGUnOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKHRoaXNbJ3JlJ10pICYmIGlzRmluaXRlKHRoaXNbJ2ltJ10pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGEgY29tcGxleCBudW1iZXIgaXMgYXQgdGhlIGluZmluaXR5IHBvbGUgb2YgdGhlXG4gICAqIFJpZW1hbm4gc3BoZXJlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gICdpc0luZmluaXRlJzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhdGhpc1snaXNGaW5pdGUnXSgpO1xuICB9XG59O1xuXG5Db21wbGV4WydaRVJPJ10gPSBuZXcgQ29tcGxleCgwLCAwKTtcbkNvbXBsZXhbJ09ORSddID0gbmV3IENvbXBsZXgoMSwgMCk7XG5Db21wbGV4WydJJ10gPSBuZXcgQ29tcGxleCgwLCAxKTtcbkNvbXBsZXhbJ1BJJ10gPSBuZXcgQ29tcGxleChNYXRoLlBJLCAwKTtcbkNvbXBsZXhbJ0UnXSA9IG5ldyBDb21wbGV4KE1hdGguRSwgMCk7XG5Db21wbGV4WydJTkZJTklUWSddID0gbmV3IENvbXBsZXgoSW5maW5pdHksIEluZmluaXR5KTtcbkNvbXBsZXhbJ05BTiddID0gbmV3IENvbXBsZXgoTmFOLCBOYU4pO1xuQ29tcGxleFsnRVBTSUxPTiddID0gMWUtMTU7XG5leHBvcnQge1xuICBDb21wbGV4IGFzIGRlZmF1bHQsIENvbXBsZXhcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/complex.js/dist/complex.mjs\n");

/***/ })

};
;